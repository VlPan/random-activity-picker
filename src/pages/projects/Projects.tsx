import { Box, Typography, Button } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import { useState } from 'react';
import { useProjectContext } from '../../contexts/ProjectContext';
import { useUserContext } from '../../contexts/UserContext';
import ProjectCard from './ProjectCard';
import CreateProjectDialog from './CreateProjectDialog';
import ProjectTaskRewardDialog from './ProjectTaskRewardDialog';
import type { Project, ProjectTask } from '../../models/project';

const Projects = () => {
  const { projects, addProject, updateProject, deleteProject, completeTask, updateTask } = useProjectContext();
  const { updatePoints } = useUserContext();
  
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [editingProject, setEditingProject] = useState<Project | undefined>(undefined);
  
  const [rewardDialogState, setRewardDialogState] = useState<{
    open: boolean;
    projectId: string;
    taskId: string;
    taskName: string;
    minReward: number;
    maxReward: number;
  }>({
    open: false,
    projectId: '',
    taskId: '',
    taskName: '',
    minReward: 0,
    maxReward: 0
  });

  const handleCreateProject = (projectData: any) => {
    if (editingProject) {
      // For updates, we need to map the tasks back to include IDs if they were existing
      // or generate new IDs if they are new. 
      // However, CreateProjectDialog returns a structure for creation.
      // Since our dialog implementation for editing is a bit simplistic (it passes raw tasks back),
      // we need to be careful. The Context's updateProject expects a full Project object.
      
      // Let's reconstruct the project object
      const updatedProject: Project = {
        ...editingProject,
        name: projectData.name,
        startDate: projectData.startDate,
        endDate: projectData.endDate,
        // We need to preserve completion status of existing tasks
        tasks: projectData.tasks.map((t: any) => {
            // If t has an ID, check if it matches an existing task in the project being edited
            // The dialog now returns tasks with IDs (either existing task ID or new UUID for new tasks)
            
            // Check if this task ID exists in the ORIGINAL project
            const existingTask = editingProject.tasks.find(et => et.id === t.id);
            
            if (existingTask) {
                // If it exists, update its details but KEEP its status
                return {
                    ...existingTask,
                    name: t.name,
                    rewardMin: t.rewardMin,
                    rewardMax: t.rewardMax
                    // isCompleted and completedAt are preserved from existingTask
                };
            } else {
                // It's a new task (or one that didn't match an ID, unlikely given our dialog logic)
                return {
                    id: t.id, // Use the ID generated by the dialog
                    name: t.name,
                    rewardMin: t.rewardMin,
                    rewardMax: t.rewardMax,
                    isCompleted: false
                };
            }
        })
      };
      
      updateProject(updatedProject);
      setEditingProject(undefined);
    } else {
      addProject(projectData);
    }
    setIsCreateDialogOpen(false);
  };

  const handleEditClick = (project: Project) => {
    setEditingProject(project);
    setIsCreateDialogOpen(true);
  };

  const handleDeleteClick = (id: string) => {
      if (confirm('Are you sure you want to delete this project?')) {
          deleteProject(id);
      }
  };

  const handleTaskCompleteClick = (projectId: string, taskId: string) => {
    const project = projects.find(p => p.id === projectId);
    if (!project) return;
    const task = project.tasks.find(t => t.id === taskId);
    if (!task) return;

    if (task.isCompleted) return; // Already completed

    setRewardDialogState({
        open: true,
        projectId,
        taskId,
        taskName: task.name,
        minReward: task.rewardMin,
        maxReward: task.rewardMax
    });
  };

  const handleRewardConfirm = (amount: number) => {
      const { projectId, taskId, taskName } = rewardDialogState;
      
      // 1. Update project task status
      completeTask(projectId, taskId);
      
      // 2. Update user points/history
      const project = projects.find(p => p.id === projectId);
      const projectName = project ? project.name : 'Unknown Project';
      
      updatePoints(amount, `Project: ${projectName} - ${taskName}`, undefined, undefined, 'Project');
      
      setRewardDialogState(prev => ({ ...prev, open: false }));
  };

  const handleTaskReorder = (projectId: string, tasks: ProjectTask[]) => {
    const project = projects.find(p => p.id === projectId);
    if (project) {
        updateProject({ ...project, tasks });
    }
  };

  return (
    <Box sx={{ maxWidth: 800, mx: 'auto' }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h4">Projects</Typography>
        <Button 
          variant="contained" 
          startIcon={<AddIcon />}
          onClick={() => {
            setEditingProject(undefined);
            setIsCreateDialogOpen(true);
          }}
        >
          Create Project
        </Button>
      </Box>
      
      {projects.length === 0 ? (
        <Typography variant="body1" color="text.secondary" sx={{ textAlign: 'center', mt: 4 }}>
          No projects yet. Create one to get started!
        </Typography>
      ) : (
        <Box sx={{ display: 'flex', flexDirection: 'column' }}>
            {[...projects].sort((a, b) => {
                // First, sort by important status: important projects go to the top
                const isImportantA = a.isImportant || false;
                const isImportantB = b.isImportant || false;
                
                if (isImportantA && !isImportantB) return -1;
                if (!isImportantA && isImportantB) return 1;
                
                // If both have the same important status, sort by status: unset projects go to the bottom
                const statusA = a.status || 'unset';
                const statusB = b.status || 'unset';
                const isUnsetA = statusA === 'unset';
                const isUnsetB = statusB === 'unset';
                
                // If one is unset and the other isn't, unset goes to bottom
                if (isUnsetA && !isUnsetB) return 1;
                if (!isUnsetA && isUnsetB) return -1;
                
                // If both have the same status category (both unset or both not unset),
                // sort by days left
                const daysLeftA = Math.ceil((new Date(a.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));
                const daysLeftB = Math.ceil((new Date(b.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));
                return daysLeftA - daysLeftB;
            }).map(project => (
                <ProjectCard 
                    key={project.id} 
                    project={project}
                    onEdit={handleEditClick}
                    onProjectUpdate={updateProject}
                    onDelete={handleDeleteClick}
                    onTaskComplete={(taskId) => handleTaskCompleteClick(project.id, taskId)}
                    onTaskReorder={handleTaskReorder}
                    onTaskUpdate={updateTask}
                />
            ))}
        </Box>
      )}

      <CreateProjectDialog 
        open={isCreateDialogOpen}
        onClose={() => {
            setIsCreateDialogOpen(false);
            setEditingProject(undefined);
        }}
        onSave={handleCreateProject}
        initialData={editingProject}
      />

      <ProjectTaskRewardDialog
        open={rewardDialogState.open}
        taskName={rewardDialogState.taskName}
        minReward={rewardDialogState.minReward}
        maxReward={rewardDialogState.maxReward}
        onClose={() => setRewardDialogState(prev => ({ ...prev, open: false }))}
        onConfirm={handleRewardConfirm}
      />
    </Box>
  );
};

export default Projects;
